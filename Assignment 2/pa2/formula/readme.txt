The design and implementation :
	For formula.c, the input is the power and I transfer the input from string to a integer by the first for loop. Then I check if the input power is less than 0, if so, complain ERROR that the input is too less and return. Then I check the first coefficient of the polynomial to see if the input is too large by pass the power and 0 to nCr(). If the return value is 0 then complain ERROR that the input is too large and return. Then I print the first element of the polynomial that is always "1" and then use a for loop to get the every element of the polynomial and print that out.	For the time used, I get the local time at the very begining of the program and store the microseconds in an integer and do that as the same at the very end to compute the used time and print out.
	
	For nCr(), I write a nCr.c contains nCr function and factorial function and transfer that into assembly code by gcc -S.  In nCr.c, the factorial funtion is a recursive function. Since it is a 64-bit system so the largest factorial we can compute is 20! because 21! > 2^63 - 1. So I check if the input is bigger than 20, and if so ,return 0 as professor requested to express an ERROR. If not, I check if n <= 0, if so ,return 1 to end the recursive. If else, return n * Factorial(n-1) for the next loop. 	 For the function nCr, I first get the value of a = Factorial(n), b = Factorial(r) and c = Factorial(n-r). Then I check if a == 0, since n is the largest value among n, r, n-r, as long as a is fine, then the other three is fine. If a == 0 ,return 0 to report that the input is too large. If not, return a/(b*c) as the result.

	I changed a little of the nCr.s get by gcc command. In the previous nCr.s when doing the process like computing a = Factorial(n), it takes more steps to assign -24(%rbp) to %edi for call Factorial and I fixed it a little better for all 3 process that call Factorial. You can check it since I also uploaded my nCr.c.

The Big-O :
	The process costs most time is this program is the to get the coefficients of the polynomial. If the input is n, then the function nCr need to run n times. And for every time nCr runs, the function Factorial needs to run n + r + (n-r) times = 2n times (wrost case). So the Big-O for this program is O(n*2n) = O(n^2).
